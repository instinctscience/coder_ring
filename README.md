# CoderRing

Provides short, unique codes upon request.

A code generated by the system is comprised of three elements, concatenated
together:

1. The supplied `:extra` string. This `get_code/2` option is entirely
   optional, but if supplied, it should not repeat. An example use case is
   the year as 2 digits.
2. An "extra" bit managed by CoderRing. If the number of codes generated in
    the seed is not exhausted, this should be an empty string. When the ring
    wraps around, a character or so may be used here. Also, if `get_code/2`
    is called with the `:retries` option greater than zero, then this will be
    incremented and the ring cycle reset.
3. The base code, coming directly from the seed data in the database.

## Explanation

The database is seeded with every possible base code. With the default of 4
characters, each being one of 32 possible characters, the database will be
populated with 1,048,576 possibilities. The 32 possible characters include
`2-9` and `A-Z`, not including `I` or `O`. This set was chosen to avoid
ambiguity for human eyes.

When a code is requested with `get_code/2`, "max" is decremented by 1 from
the max used in finding the last code. (If it's the first code fetched, "max"
is the last record.) "r" is then a random number between 1 and "max",
inclusive. Records "r" and "max" are found in the table by their "position"
field (numbering the records from 1). The values for records "r" and "max"
are reversed, and the value landing out of bounds for future codes in the
"max" position is returned as the next code. This gives off the look of truly
random codes, but they never repeat.

Once the cycle completes, "max" is reset to the last record again and it
repeats. The records in the table will be randomized, but it doesn't really
matter since the records will be again pulled in random order.

## Setup

Configure your code rings in your `config.exs` with something like:

```elixir
config :coder_ring, rings: [:widget, doodad: [base_length: 2]]
```

Here, we configured two code rings. Note that the `:rings` list may have
atoms for default options or keyword list-style entries (`{:doodad,
base_length: 2}`) if options are specified.

Next, add the following to `change/0` in a new or existing Ecto migration:

```elixir
def change do
  CoderRing.Migration.change()
end
```

Make sure the database tables are seeded somewhere before use, whether in
your existing `seeds.exs` or other application code:

```elixir
CoderRing.populate_rings_if_empty()
```

Finally, create a module like this in your application:

```elixir
defmodule MyApp.CoderRing do
  use CoderRing
end
```

Now you can use `MyApp.CoderRing.get_code/2` to generate new codes.

```elixir
iex> MyApp.CoderRing.get_code(:widget)
"7GRY"
iex> MyApp.CoderRing.get_code(:widget)
"PJ83"
iex> MyApp.CoderRing.get_code(:widget)
"NNW3"
iex> MyApp.CoderRing.get_code(:widget)
"Q5QA"
```

## Acknowledgements

The methodology is appreciatively derived from Robert Gamble's accepted
answer on [this Stack Overflow
page](https://stackoverflow.com/questions/196017/unique-non-repeating-random-numbers-in-o1/16097246#16097246).